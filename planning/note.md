# 记录在开发过程中受阻的一些事情&处理方式

1. 当我初始化游戏的时候，多维数组应该选择以宽度为第一层数组还是以高度为第一层数组呢？  
  > 最后选择更直观的方式：以高度为第一层数组，这样方块在下移的过程中，只需要挪动下标即可，当我们获得到下标前一个位置不为空，也就知道了，我们达到的`触底`的状态。
2. 如何将新的方块塞进去？
  > 因为方块可能是不规则图形，类似于这样`[[1, 1, 1], [0, 1, 0]]`。如何快速的将这个数组并入现有集合便成了一个问题。
3. 如何实现方块的旋转？
  现在有两个解决方案：  
    1. 直接在初始化方块的时候，将旋转后的结果存为一个数组。。在存储一个当前状态的下标，每次旋转时，取出下一个坐标系（`low`）
    2. 写一个函数，进行数组坐标的转换  
      转换规律如下：  
        1. 第一行变为最后一列
        2. 最后一行变为第一列
      也就是说我们在给新数组第一行赋值时，需要先找到原数组最后一列，然后倒数第二列，直到第一列。
      大致顺序就是，我们先将数组进行反转（只针对第一层），然后再进行行和列的互相转换即可
4. 如何去判断触底
  在每次触发bottom、down和rotate时，都要去检查是否触底，然后如何检测触底便成了一个问题。
  我可能会有这样的数据
  ```javascript
  [
    [ 1, 1, 0],
    [ 0, 1, 0],
    [ 2, 0, 0],
    [ 2, 0, 0],
    [ 2, 2, 2]
  ]
  ```
  我要取出来最最后一行的不为空元素，如果最后一行没有元素，则继续往上一个行元素去查找，然后将他们对应的下标返回出来，与当前活动的方块坐标相加，再将下标+1，查看是否有值 or 是否已经达到底部（>= `height`），如果满足任意情况则说明已经触底了。
  所以现在就要写这么一个函数了，将每列的最后一个非空元素坐标取出来，而且每次都这么调用未免太浪费性能了，所以我决定在函数调用时进行一层缓存，相同结构的二维数组，直接返回之前计算好的数据。
  在这里，直接复用了上边的旋转方块的方法，然后写了个递归进行获取index，但是要注意的一点：**用数组的长度减去这个index才是我们真正想要的index**  
5. 如何实现快速达到底部
  同样有两种方法：    
    1. 循环调用`move.done`（`low`）  
    2. 获取当前游戏中已有的方块位置，取出最上一层的下标，然后对应的下标`-1`就是方块最远可以下降的位置。
      我们现在已经拿到了之前老方块的位置，现在需要判断出方块最大可以下滑的幅度。考虑到方块可能是不规则的形状，所以说我们应该取下落列中最小的那个值，比如我们拿到了如下坐标：  
      ```javascript
      [10, 10, 10, 10, 10] // 此为底部最高可下降至的位置
      [1, 2, 1, 1]         // 此为当前方块最下边一行的坐标
      // 所以我们要取出差值最小的那个值来使用，因为如果取大的那个差值，将会导致差值小的列重叠
      ```
